/**
 * @fileoverview Firestore Security Rules for TaxiTao Application
 * 
 * SECURITY MODEL: Split-Data Architecture
 * ========================================
 * This ruleset implements a split-data model where:
 * - Public booking data (areas, times, fares) is readable by any driver
 * - Private customer data (phone, exact addresses) requires active subscription
 * 
 * COLLECTIONS:
 * - /users/{userId}: Private user profiles (role, driverId)
 * - /drivers/{driverId}: Public driver profiles (readable by anyone)
 * - /vehicles/{vehicleId}: Public vehicle info (readable by anyone)
 * - /bookingRequests/{id}: PUBLIC ride data (areas, date/time, fare estimate)
 * - /bookingRequestPrivate/{id}: PRIVATE customer data (phone, exact addresses) - SUBSCRIPTION REQUIRED
 * - /rideShares/{shareId}: Shared link metadata with timestamps for ±3 min verification
 * - /paymentVerifications/{id}: M-Pesa confirmation tracking
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================
    // HELPER FUNCTIONS
    // ============================================================
    
    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }
    
    // Check if user owns this resource
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Get current user's profile data
    function getUserData() {
      return isSignedIn() 
        ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data 
        : null;
    }
    
    // Check if user is admin
    function isAdmin() {
      return isSignedIn() && 
             getUserData() != null && 
             getUserData().role == 'admin';
    }
    
    // Check if user is a driver
    function isDriver() {
      return isSignedIn() && 
             getUserData() != null && 
             getUserData().role == 'driver';
    }
    
    // Get driver's subscription data (only for drivers)
    function getDriverSubscription() {
      return isDriver() && getUserData().driverId != null 
        ? get(/databases/$(database)/documents/drivers/$(getUserData().driverId)).data 
        : null;
    }
    
    // Check if driver has ACTIVE subscription (critical for private data access)
    function isSubscribedDriver() {
      return isDriver() && 
             getUserData().driverId != null &&
             getDriverSubscription() != null &&
             getDriverSubscription().subscriptionStatus == 'active' && 
             getDriverSubscription().isVisibleToPublic == true;
    }

    // Check if current user matches the driver for a resource
    function driverMatches(driverId) {
      // Allow match by auth uid OR driverId stored on profile (even if role not set yet)
      return isSignedIn() && (
        request.auth.uid == driverId ||
        (getUserData() != null && getUserData().driverId == driverId)
      );
    }

    // Check if requester is allowed to see/update a negotiation
    function negotiationParticipant(driverId, customerId) {
      return isAdmin() ||
             driverMatches(driverId) ||
             (isSignedIn() && customerId != null && request.auth.uid == customerId);
    }

    // Prevent mutation of immutable negotiation fields on updates
    function negotiationImmutableFieldsUnchanged() {
      return request.resource.data.driverId == resource.data.driverId &&
             request.resource.data.customerId == resource.data.customerId &&
             request.resource.data.bookingRequestId == resource.data.bookingRequestId &&
             request.resource.data.customerName == resource.data.customerName &&
             request.resource.data.customerPhone == resource.data.customerPhone &&
             request.resource.data.initialPrice == resource.data.initialPrice &&
             request.resource.data.proposedPrice == resource.data.proposedPrice;
    }

    // ============================================================
    // DEFAULT: Block all access unless explicitly allowed
    // ============================================================
    match /{document=**} {
      allow read, write: if false;
    }

    // ============================================================
    // USER PROFILES
    // ============================================================
    match /users/{userId} {
      // Users can read/update/delete their own profile
      allow read, update, delete: if isSignedIn() && isOwner(userId);
      // Any authenticated user can create their profile
      allow create: if isSignedIn();
      // Admins can list all users
      allow list: if isAdmin();
    }

    // ============================================================
    // DRIVER PROFILES (Public for marketing)
    // ============================================================
    match /drivers/{driverId} {
      // Anyone can read driver profiles (for booking UI)
      allow read: if true;
      // Drivers can create/update their own profile
      allow create: if isSignedIn() && (isOwner(driverId) || isAdmin());
      allow update: if isSignedIn() && (isOwner(driverId) || isAdmin());
      // Only admins can delete
      allow delete: if isAdmin();
      
      // Nested vehicles subcollection
      match /vehicles/{vehicleId} {
        allow read, write: if isSignedIn() && (isOwner(driverId) || isAdmin());
      }
      
      // Nested payments subcollection
      match /payments/{paymentId} {
        allow read: if isSignedIn() && (isOwner(driverId) || isAdmin());
        allow write: if isSignedIn() && isOwner(driverId);
      }
    }

    // ============================================================
    // DRIVER ROUTES (TaxiTao Mobile compatibility)
    // ============================================================
    match /driverRoutes/{routeId} {
      // Drivers can create their own routes with required fields
      allow create: if isSignedIn()
        && request.resource.data.driverId == request.auth.uid
        && request.resource.data.price is number
        && request.resource.data.fromLocation is string
        && request.resource.data.toLocation is string;

      // Only route owner can update/delete
      allow update, delete: if isSignedIn()
        && resource.data.driverId == request.auth.uid;

      // Reads: driver can read own, customers can read active routes
      allow get, list: if isSignedIn() && (
        resource.data.driverId == request.auth.uid ||
        resource.data.active == true
      );
    }

    // ============================================================
    // VEHICLES (Top-level, public read for booking display)
    // ============================================================
    match /vehicles/{vehicleId} {
      allow read: if true;
      allow create: if isSignedIn() && (
        request.resource.data.driverId == request.auth.uid || isAdmin()
      );
      allow update, delete: if isSignedIn() && (
        resource.data.driverId == request.auth.uid || isAdmin()
      );
    }

    // ============================================================
    // BOOKING REQUESTS - PUBLIC DATA ONLY
    // Contains: pickupArea, dropoffArea, pickupDate, pickupTime, 
    //           estimatedFare, status, passengers
    // Does NOT contain: customerPhone, customerName, exact addresses
    // ============================================================
    match /bookingRequests/{bookingId} {
      // Anyone can create bookings (guest customers)
      allow create: if true;
      
      // Reading: All signed-in drivers can see public booking info
      allow get: if isSignedIn() && (
        isDriver() || 
        isAdmin() ||
        // Check if acceptedBy matches user's driverId OR user.uid
        (isDriver() && resource.data.acceptedBy == getUserData().driverId) ||
        resource.data.acceptedBy == request.auth.uid ||
        resource.data.customerId == request.auth.uid
      );
      
      // Drivers/admins can list; customers can list their own; drivers can list their accepted bookings even if profile role is missing
      allow list: if isSignedIn() && (
        isDriver() || 
        isAdmin() ||
        resource.data.customerId == request.auth.uid ||
        resource.data.acceptedBy == request.auth.uid ||
        (getUserData() != null && resource.data.acceptedBy == getUserData().driverId)
      );
      
      // Updates: Drivers can accept/update, customers can rate
      allow update: if isSignedIn() && (
        // Driver accepting pending booking
        (isDriver() && resource.data.status == 'pending') ||
        // Driver updating their accepted booking (check both driverId and user.uid)
        (isDriver() && (
          resource.data.acceptedBy == getUserData().driverId ||
          resource.data.acceptedBy == request.auth.uid
        )) || 
        // Customer rating completed ride
        (resource.data.customerId == request.auth.uid && 
         resource.data.rideStatus == 'completed' &&
         resource.data.rating == null) ||
        isAdmin()
      );
      
      allow delete: if isAdmin();
    }

    // ============================================================
    // BOOKING REQUESTS - PRIVATE DATA (SUBSCRIPTION REQUIRED)
    // Contains: customerName, customerPhone, exactPickup, exactDropoff
    // ============================================================
    match /bookingRequestPrivate/{bookingId} {
      // CRITICAL: Only subscribed drivers OR admins can read private data
      allow read: if isSignedIn() && (isSubscribedDriver() || isAdmin());
      
      // System creates during booking flow
      allow create: if true;
      
      // Only admins can modify
      allow update, delete: if isAdmin();
    }

    // ============================================================
    // RIDE SHARES (Time-gated link verification)
    // Used for ±3 minute payment verification
    // ============================================================
    match /rideShares/{shareId} {
      // Anyone can read (to validate share link exists)
      allow read: if true;
      
      // Only admins/system can create share links
      allow create: if isSignedIn() && (isAdmin() || isDriver());
      
      // Drivers can claim (update) share links
      allow update: if isSignedIn() && isDriver();
      
      allow delete: if isAdmin();
    }

    // ============================================================
    // PAYMENT VERIFICATIONS (M-Pesa confirmation tracking)
    // ============================================================
    match /paymentVerifications/{verificationId} {
      // Drivers can create verification requests
      allow create: if isSignedIn() && isDriver();
      
      // Drivers can read their own, admins can read all
      allow read: if isSignedIn() && (
        resource.data.driverId == request.auth.uid || isAdmin()
      );
      
      // Only admins can verify/reject
      allow update, delete: if isAdmin();
    }

    // ============================================================
    // USER BOOKINGS (Private user data)
    // ============================================================
    match /users/{userId}/bookings/{bookingId} {
      allow read, write: if isSignedIn() && isOwner(userId);
    }

    // ============================================================
    // DRIVER PRICING
    // ============================================================
    match /driverPricing/{driverId} {
      allow read: if true;
      allow write: if isSignedIn() && (
        getUserData().driverId == driverId || isAdmin()
      );
    }

    // ============================================================
    // STANDARD PRICING
    // ============================================================
    match /pricing/{priceId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // ============================================================
    // NEGOTIATIONS
    // ============================================================
    match /negotiations/{negotiationId} {
      // Anyone can start a negotiation (guest customers allowed)
      allow create: if true;

      // Read: participants (customer or driver) or admin.
      // For guest negotiations (customerId == null), allow read by possession of the link/id.
      allow get: if negotiationParticipant(resource.data.driverId, resource.data.customerId) ||
                 resource.data.customerId == null;

      // List: only participants (customer/driver) or admin to avoid broad enumeration
      allow list: if negotiationParticipant(resource.data.driverId, resource.data.customerId);

      // Updates: participants or admin, and guests when customerId is null,
      // while keeping immutable fields locked.
      allow update: if negotiationImmutableFieldsUnchanged() && (
        negotiationParticipant(resource.data.driverId, resource.data.customerId) ||
        (resource.data.customerId == null && request.resource.data.customerId == null)
      );

      // Delete restricted to admins
      allow delete: if isAdmin();
    }

    // ============================================================
    // RIDE REQUESTS (Legacy fallback)
    // ============================================================
    match /rideRequests/{requestId} {
      allow create: if true;
      allow read: if isSignedIn() && (isDriver() || isAdmin());
      allow update: if isSignedIn() && (
        (isDriver() && resource.data.status == 'pending') ||
        (isDriver() && resource.data.driverId == getUserData().driverId) ||
        isAdmin()
      );
      allow delete: if isAdmin();
    }

    // ============================================================
    // NOTIFICATIONS
    // ============================================================
    match /notifications/{notificationId} {
      // Allow customers, drivers (via driverId), system broadcast, or admin
      allow read: if isSignedIn() && (
        request.auth.uid == resource.data.recipientId ||
        driverMatches(resource.data.recipientId) ||
        resource.data.recipientId == 'system_broadcast' ||
        isAdmin()
      );
      allow create: if true;
      allow update: if isSignedIn() && (
        request.auth.uid == resource.data.recipientId ||
        driverMatches(resource.data.recipientId) ||
        isAdmin()
      );
      allow delete: if isSignedIn() && (
        request.auth.uid == resource.data.recipientId ||
        driverMatches(resource.data.recipientId) ||
        isAdmin()
      );
    }

    match /driverNotifications/{notificationId} {
      allow create: if true;
      allow read, update, delete: if isSignedIn() && (
        // Check if driverId matches user's driverId from profile OR matches user.uid directly
        (isDriver() && getUserData().driverId == resource.data.driverId) ||
        request.auth.uid == resource.data.driverId || 
        isAdmin()
      );
    }

    // ============================================================
    // CLIENT ISSUES
    // ============================================================
    match /client_issues/{issueId} {
      allow create: if isSignedIn();
      allow get, list, update, delete: if isAdmin();
    }
  }
}
