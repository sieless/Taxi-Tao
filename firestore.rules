/**
 * @fileoverview Firestore Security Rules for TaxiTao Application
 * 
 * SECURITY MODEL: Split-Data Architecture
 * ========================================
 * This ruleset implements a split-data model where:
 * - Public booking data (areas, times, fares) is readable by any driver
 * - Private customer data (phone, exact addresses) requires active subscription
 * 
 * COLLECTIONS:
 * - /users/{userId}: Private user profiles (role, driverId)
 * - /drivers/{driverId}: Public driver profiles (readable by anyone)
 * - /vehicles/{vehicleId}: Public vehicle info (readable by anyone)
 * - /bookingRequests/{id}: PUBLIC ride data (areas, date/time, fare estimate)
 * - /bookingRequestPrivate/{id}: PRIVATE customer data (phone, exact addresses) - SUBSCRIPTION REQUIRED
 * - /rideShares/{shareId}: Shared link metadata with timestamps for ±3 min verification
 * - /paymentVerifications/{id}: M-Pesa confirmation tracking
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================
    // HELPER FUNCTIONS
    // ============================================================
    
    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }
    
    // Check if user's email is verified (REQUIRED for account access)
    function isEmailVerified() {
      return isSignedIn() && request.auth.token.email_verified == true;
    }
    
    // Check if user owns this resource
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Check if user is NOT suspended
    function isNotSuspended() {
      return isSignedIn() && (
        !exists(/databases/$(database)/documents/users/$(request.auth.uid)) ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.suspended != true
      );
    }
    
    // Get current user's profile data
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    // Check if user is admin (requires email verification)
    function isAdmin() {
      return isSignedIn() && 
             isEmailVerified() &&
             getUserData().role == 'admin' &&
             getUserData().suspended != true;
    }
    
    // Check if user is a driver (requires email verification)
    function isDriver() {
      return isSignedIn() && 
             isEmailVerified() &&
             getUserData().role == 'driver' &&
             getUserData().suspended != true;
    }
    
    // Get driver's subscription data (only for drivers)
    function getDriverSubscription() {
      return isDriver() && getUserData().driverId != null 
        ? get(/databases/$(database)/documents/drivers/$(getUserData().driverId)).data 
        : null;
    }
    
    // Check if driver has ACTIVE subscription (critical for private data access)
    function isSubscribedDriver() {
      return isDriver() && 
             getUserData().driverId != null &&
             getDriverSubscription() != null &&
             getDriverSubscription().subscriptionStatus == 'active' && 
             getDriverSubscription().isVisibleToPublic == true;
    }

    // Check if current user matches the driver for a resource
    function driverMatches(driverId) {
      // Allow match by auth uid OR driverId stored on profile (even if role not set yet)
      return isSignedIn() && (
        request.auth.uid == driverId ||
        (getUserData() != null && getUserData().driverId == driverId)
      );
    }

    // Check if requester is allowed to see/update a negotiation
    function negotiationParticipant(driverId, customerId) {
      return isAdmin() ||
             driverMatches(driverId) ||
             (isSignedIn() && customerId != null && request.auth.uid == customerId);
    }

    // Prevent mutation of immutable negotiation fields on updates
    function negotiationImmutableFieldsUnchanged() {
      return request.resource.data.driverId == resource.data.driverId &&
             request.resource.data.customerId == resource.data.customerId &&
             request.resource.data.bookingRequestId == resource.data.bookingRequestId &&
             request.resource.data.customerName == resource.data.customerName &&
             request.resource.data.customerPhone == resource.data.customerPhone &&
             request.resource.data.initialPrice == resource.data.initialPrice &&
             request.resource.data.proposedPrice == resource.data.proposedPrice;
    }

    // ============================================================
    // DEFAULT: Block all access unless explicitly allowed
    // ============================================================
    match /{document=**} {
      allow read, write: if false;
    }

    // ============================================================
    // USER PROFILES
    // ============================================================
    match /users/{userId} {
      // Users can read their own profile (email verification required) or admins can read all
      allow read: if isSignedIn() && (isOwner(userId) && isEmailVerified() || isAdmin());
      
      // Users can create their own profile (email verification not required during signup)
      // Admins can create any profile
      allow create: if isSignedIn() && (isOwner(userId) || isAdmin());
      
      // Users can update their own profile (email verification required) or admins can update any
      allow update: if isSignedIn() && ((isOwner(userId) && isEmailVerified()) || isAdmin());
      
      // Only admins can delete users
      allow delete: if isAdmin();
      
      // Admins can list all users
      allow list: if isAdmin();
    }

    // ============================================================
    // DRIVER PROFILES (Mobile: auth read, self write)
    // ============================================================
    match /drivers/{driverId} {
      // Anyone authenticated with verified email can read driver profiles (for booking flow)
      allow read: if isSignedIn() && isEmailVerified();
      // Drivers can create their own profile (email verification required), or admins can create any
      allow create: if isSignedIn() && (
        (request.auth.uid == driverId && isEmailVerified()) ||
        isAdmin()
      );

      // Drivers can update their own profile (email verification required), or admins can update any
      allow update: if isSignedIn() && (
        (request.auth.uid == driverId && isEmailVerified()) ||
        isAdmin()
      );

      // Only admins can delete driver profiles
      allow delete: if isSignedIn() && isAdmin();
      
      // Nested vehicles subcollection
      match /vehicles/{vehicleId} {
        allow read, write: if isSignedIn() && (isOwner(driverId) || isAdmin());
      }
      
      // Nested payments subcollection
      match /payments/{paymentId} {
        allow read: if isSignedIn() && (isOwner(driverId) || isAdmin());
        allow write: if isSignedIn() && isOwner(driverId);
      }
    }

    // ============================================================
    // DRIVER ROUTES (TaxiTao Mobile compatibility)
    // ============================================================
    match /driverRoutes/{routeId} {
      // Anyone can read routes (customers need to see pricing options)
      allow read: if request.auth != null;

      // Only the route owner (driver) can create/modify/delete
      allow create: if request.auth != null && request.auth.uid == request.resource.data.driverId;
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.driverId;
    }

    // ============================================================
    // VEHICLES (Top-level, public read for booking display)
    // ============================================================
    match /vehicles/{vehicleId} {
      allow read: if true;
      allow create: if isSignedIn() && (
        request.resource.data.driverId == request.auth.uid || isAdmin()
      );
      allow update, delete: if isSignedIn() && (
        resource.data.driverId == request.auth.uid || isAdmin()
      );
    }

    // ============================================================
    // BOOKING REQUESTS - PUBLIC DATA ONLY
    // Contains: pickupArea, dropoffArea, pickupDate, pickupTime, 
    //           estimatedFare, status, passengers
    // Does NOT contain: customerPhone, customerName, exact addresses
    // ============================================================
    match /bookingRequests/{bookingId} {
      // Any authenticated user with verified email can create a booking request
      allow create: if isSignedIn() && isEmailVerified();

      // Any authenticated user with verified email can read (drivers scan for rides in area)
      allow read: if isSignedIn() && isEmailVerified();
      
      // Update logic - multi-party access (email verification required)
      allow update: if isSignedIn() && isEmailVerified() && (
        // Customer who created the booking (can cancel, negotiate, confirm)
        request.auth.uid == resource.data.customerId ||

        // Driver who accepted the booking (can update status and location)
        request.auth.uid == resource.data.acceptedBy ||

        // Targeted driver (can accept a specifically-assigned ride)
        request.auth.uid == resource.data.targetDriverId ||

        // Any driver can accept a PENDING broadcast ride
        (resource.data.status == 'pending')
      );
      
      // Allow deletion of rides under specific conditions (email verification required):
      // 1. Driver can delete expired rides they accepted (for cleanup)
      // 2. Driver can delete expired rides where they were chosen by customer (for cleanup)
      // 3. Customer can delete their own cancelled rides (for cleanup)
      allow delete: if isSignedIn() && isEmailVerified() && (
        // Driver can delete expired rides they accepted
        (request.auth.uid == resource.data.acceptedBy &&
         resource.data.expiresAt != null &&
         (resource.data.expiresAt.toMillis ? resource.data.expiresAt.toMillis() : resource.data.expiresAt) < request.time.toMillis()) ||
        // Driver can delete expired rides where they were targeted by customer
        (request.auth.uid == resource.data.targetDriverId &&
         resource.data.expiresAt != null &&
         (resource.data.expiresAt.toMillis ? resource.data.expiresAt.toMillis() : resource.data.expiresAt) < request.time.toMillis()) ||
        // Customer can delete their own cancelled rides
        (request.auth.uid == resource.data.customerId &&
         resource.data.status == 'cancelled')
      );
    }

    // ============================================================
    // BOOKING REQUESTS - PRIVATE DATA (SUBSCRIPTION REQUIRED)
    // Contains: customerName, customerPhone, exactPickup, exactDropoff
    // ============================================================
    match /bookingRequestPrivate/{bookingId} {
      // CRITICAL: Only subscribed drivers (with verified email) OR admins can read private data
      allow read: if isSignedIn() && isEmailVerified() && (isSubscribedDriver() || isAdmin());
      
      // System creates during booking flow (no auth required for system operations)
      allow create: if true;
      
      // Only admins can modify
      allow update, delete: if isAdmin();
    }

    // ============================================================
    // RIDE SHARES (Time-gated link verification)
    // Used for ±3 minute payment verification
    // ============================================================
    match /rideShares/{shareId} {
      // Anyone can read (to validate share link exists) - no auth required for public links
      allow read: if true;
      
      // Only admins/system can create share links (email verification required)
      allow create: if isSignedIn() && isEmailVerified() && (isAdmin() || isDriver());
      
      // Drivers can claim (update) share links (email verification required)
      allow update: if isSignedIn() && isEmailVerified() && isDriver();
      
      allow delete: if isAdmin();
    }

    // ============================================================
    // PAYMENT VERIFICATIONS (M-Pesa confirmation tracking)
    // ============================================================
    match /paymentVerifications/{verificationId} {
      // Drivers can create verification requests (email verification required)
      allow create: if isSignedIn() && isEmailVerified() && isDriver();
      
      // Drivers can read their own (email verification required), admins can read all
      allow read: if isSignedIn() && isEmailVerified() && (
        resource.data.driverId == request.auth.uid || isAdmin()
      );
      
      // Only admins can verify/reject
      allow update, delete: if isAdmin();
    }

    // ============================================================
    // USER BOOKINGS (Private user data)
    // ============================================================
    match /users/{userId}/bookings/{bookingId} {
      allow read, write: if isSignedIn() && isEmailVerified() && isOwner(userId);
    }

    // ============================================================
    // DRIVER PRICING
    // ============================================================
    match /driverPricing/{driverId} {
      allow read: if true; // Public pricing info
      allow write: if isSignedIn() && isEmailVerified() && (
        getUserData().driverId == driverId || isAdmin()
      );
    }

    // ============================================================
    // STANDARD PRICING
    // ============================================================
    match /pricing/{priceId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // ============================================================
    // NEGOTIATIONS
    // ============================================================
    match /negotiations/{negotiationId} {
      // Anyone can start a negotiation (guest customers allowed, but authenticated users need verified email)
      allow create: if !isSignedIn() || (isSignedIn() && isEmailVerified());

      // Read: participants (customer or driver) or admin (email verification required for authenticated users).
      // For guest negotiations (customerId == null), allow read by possession of the link/id.
      allow get: if !isSignedIn() || 
                 (isSignedIn() && isEmailVerified() && (
                   negotiationParticipant(resource.data.driverId, resource.data.customerId) ||
                   resource.data.customerId == null
                 ));

      // List: only participants (customer/driver) or admin to avoid broad enumeration (email verification required)
      allow list: if isSignedIn() && isEmailVerified() && 
                     negotiationParticipant(resource.data.driverId, resource.data.customerId);

      // Updates: participants or admin (email verification required), and guests when customerId is null,
      // while keeping immutable fields locked.
      allow update: if negotiationImmutableFieldsUnchanged() && (
        (!isSignedIn() || (isSignedIn() && isEmailVerified())) && (
          negotiationParticipant(resource.data.driverId, resource.data.customerId) ||
          (resource.data.customerId == null && request.resource.data.customerId == null)
        )
      );

      // Delete restricted to admins
      allow delete: if isAdmin();
    }

    // ============================================================
    // RIDE REQUESTS (Legacy fallback)
    // ============================================================
    match /rideRequests/{requestId} {
      allow create: if true;
      allow read: if isSignedIn() && (isDriver() || isAdmin());
      allow update: if isSignedIn() && (
        (isDriver() && resource.data.status == 'pending') ||
        (isDriver() && resource.data.driverId == getUserData().driverId) ||
        isAdmin()
      );
      allow delete: if isAdmin();
    }

    // ============================================================
    // NOTIFICATIONS
    // ============================================================
    match /notifications/{notificationId} {
      // Read: Only the recipient can read their notifications OR system_broadcast (email verification required)
      allow read: if isSignedIn() && isEmailVerified() && (
        request.auth.uid == resource.data.recipientId ||
        resource.data.recipientId == "system_broadcast"
      );

      // Anyone authenticated with verified email can create notifications (cross-party alerts)
      allow create: if isSignedIn() && isEmailVerified();

      // Only recipient can update (e.g., mark as read) (email verification required)
      allow update: if isSignedIn() && isEmailVerified() && request.auth.uid == resource.data.recipientId;
      
      // No deletion
      allow delete: if false;
    }

    match /driverNotifications/{notificationId} {
      // Only the driver can read their notifications (email verification required)
      allow read: if isSignedIn() && isEmailVerified() && request.auth.uid == resource.data.driverId;

      // Anyone authenticated with verified email can create (customer confirms, system alerts)
      allow create: if isSignedIn() && isEmailVerified();
      
      // Only driver can update (e.g., mark as read) (email verification required)
      allow update: if isSignedIn() && isEmailVerified() && request.auth.uid == resource.data.driverId;
      
      // No deletion
      allow delete: if false;
    }

    // ============================================================
    // ISSUES COLLECTION (Issue reports from customers and drivers)
    // ============================================================
    match /issues/{issueId} {
      // Users can read their own issues (email verification required), admins can read all
      allow read: if isSignedIn() && isEmailVerified() && (
        request.auth.uid == resource.data.userId ||
        isAdmin()
      );

      // Any authenticated user with verified email can create their own issue report
      // Must match userId and have valid userType (customer or driver)
      allow create: if isSignedIn() && isEmailVerified() &&
        request.auth.uid == request.resource.data.userId &&
        request.resource.data.userType in ['customer', 'driver'];

      // Only admins can update issue status
      allow update: if isAdmin();

      // No deletion
      allow delete: if false;
    }

    // ============================================================
    // TESTING PHASE COLLECTIONS
    // ============================================================
    
    // Testing Questions Collection
    match /testingQuestions/{questionId} {
      // TEMPORARY: Allow all authenticated users with verified email full access (for development)
      allow read, write: if isSignedIn() && isEmailVerified();
    }

    // Testing Config Collection
    match /testingConfig/{configId} {
      // TEMPORARY: Allow all authenticated users with verified email full access (for development)
      allow read, write: if isSignedIn() && isEmailVerified();
    }

    // Testing Feedback Collection
    match /testingFeedback/{feedbackId} {
      // TEMPORARY: Allow all authenticated users with verified email full access (for development)
      allow read, write: if isSignedIn() && isEmailVerified();
    }

    // Crash Reports Collection
    match /crashReports/{crashId} {
      // TEMPORARY: Allow all authenticated users with verified email full access (for development)
      allow read, write: if isSignedIn() && isEmailVerified();
    }

    // APP SETTINGS (global)
    // ============================================================
    match /appSettings/{settingId} {
      allow read: if isSignedIn() && isEmailVerified();
      allow create, update: if isAdmin();
      allow delete: if false;
    }
  }
}
